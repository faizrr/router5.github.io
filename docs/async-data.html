<!doctype html>

<html>

<head>
    <base href="/">
    <title>router5 | flexible and powerful routing solution for web applications</title>
    <!-- Meta -->
    <meta name="description" content="router5 is an HTML5 router, simple but powerful.">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="google-site-verification" content="U9xvaIGsCTplxQ8c8ROAGZabhs6AWZ6gupLXEYzgHK8" />
    <!-- Twitter Card data -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="router5">
    <meta name="twitter:description" content="Simple, framework-agnostic, powerful and functional HTML5 routing solution.">
    <meta name="twitter:creator" content="@tcroch">
    <meta name="twitter:image" content="http://router5.github.io/logo/r5_128.png">
    <!-- Open Graph data -->
    <meta property="og:title" content="router5">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://router5.github.io">
    <meta property="og:description" content="Simple, framework-agnostic, powerful and functional HTML5 routing solution.">
    <meta property="og:image" content="http://router5.github.io/logo/r5_128.png">
    <!-- Stylsheets -->
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/github-gist.min.css">
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="/styles/docs.css">
    <link rel="stylesheet" href="/styles/examples.css">
    
</head>

<body>
    
        <header>
        <nav class="">
            <a href="/" class="">Home</a>

            <a href="/docs/why-router5.html" class="">Getting started</a>

            <a href="/docs/configuring-routes.html" class="active">Guides</a>

            <a href="/docs/api-reference.html" class="">API</a>

            <a href="docs/with-react.html" class="">Examples</a>

            <iframe src="https://ghbtns.com/github-btn.html?user=router5&repo=router5&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
        </nav>
    </header>


    <aside>
        <nav>
            <strong>Getting started</strong>

            <a href="/docs/why-router5.html" class="link">Why router5?</a>
            <a href="/docs/installation.html" class="link">Installation</a>
            <!-- <a href="/docs/first-router.html" class="link">Your first router</a> -->
            <a href="/docs/ecosystem.html" class="link">Ecosystem</a>

            <strong>Docs</strong>

            <a href="/docs/migration-5.html" class="link">Migrating to v5</a>
            <a href="/docs/api-reference.html" class="link">Router5 API</a>
            <a href="/docs/understanding-router5.html" class="link">Understanding router5</a>
            <a href="/docs/transition.html" class="link">Transition phase</a>

            <strong>Guides</strong>

            <a href="/docs/configuring-routes.html" class="link">Configuring routes</a>
            <a href="/docs/router-options.html" class="link">Router options</a>
            <a href="/docs/path-syntax.html" class="link">Path syntax</a>
            <a href="/docs/navigation.html" class="link">Navigation</a>
            <a href="/docs/universal-applications.html" class="link">Universal applications</a>
            <a href="/docs/preventing-navigation.html" class="link">Preventing navigation</a>
            <a href="/docs/middleware.html" class="link">Middleware functions</a>
            <a href="/docs/custom-errors.html" class="link">Custom errors and redirections</a>
            <a href="/docs/async-data.html" class="link active">Loading async data</a>
            <a href="/docs/plugins.html" class="link">Using plugins</a>
            <a href="/docs/injectables.html" class="link">Dependency injection</a>

            <strong>Plugins</strong>

            <a href="/docs/history.html" class="link">Browser</a>
            <a href="/docs/listeners.html" class="link">Listeners</a>

            <strong>Examples</strong>

            <a href="/docs/with-react.html" class="link">With React</a>
            <a href="/docs/with-react-redux.html" class="link">With React and Redux</a>
            <a href="/docs/with-deku.html" class="link">With Deku</a>
            <a href="/docs/with-deku-redux.html" class="link">With Deku and Redux</a>
            <a href="/docs/with-cycle.html" class="link">With Cycle</a>
        </nav>
    </aside>

    <main>
        &lt;h1 id=&quot;loading-async-data&quot;&gt;Loading async data&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Loading async data is always an important task of a web application. Very often, data and routes are tied to your application business logic. Therefore, loading data on a route change is very common.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The way data loading can work with routing depends on what you might call your &amp;quot;routing strategy&amp;quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Do you want a route transition to wait for data to be loaded?&lt;/li&gt;
&lt;li&gt;Do you want a route transition to fail if data cannot be loaded?&lt;/li&gt;
&lt;li&gt;How do you bind your view to data?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are many ways to handle data coming from a router and from an API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;your components can receive them both at the same time&lt;/li&gt;
&lt;li&gt;your components can receive a route update first and then a data update later&lt;/li&gt;
&lt;li&gt;your components can receive a route update first and decide to load data&lt;/li&gt;
&lt;li&gt;etc...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Router5 doesn&amp;#39;t provide an opinionated way of handling async data, instead this article demonstrates the tools router5 can provide to help you loading data. You shouldn&amp;#39;t view those examples as &lt;em&gt;the&lt;/em&gt; way to load data, their purpose is purely illustrative and they don&amp;#39;t cover every case (error handling, server-side data loading, etc...). Instead you should aim to do things and organise your code the way you think is best for you and your application.&lt;/p&gt;
&lt;h2 id=&quot;using-a-middleware&quot;&gt;Using a middleware&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;You can use your router state objects as a container for route-specific data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can use a middleware if you want your router to wait for data updates and/or prevent a route transition to happen if data loading fails.
When doing so, you can use &lt;code&gt;toState&lt;/code&gt; state object as a container for your route-specific data: the listeners plugin will pass it to your view (with the data you attached to it). You shouldn&amp;#39;t mutate &lt;code&gt;toState&lt;/code&gt; if you don&amp;#39;t explicitly ask the router to wait by either calling a &lt;code&gt;done&lt;/code&gt; callback or by returning a promise.&lt;/p&gt;
&lt;p&gt;First, we need to define what data need to be loaded for which route segment:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript javascript&quot;&gt;const routes = [
    {
        name: &amp;#39;home&amp;#39;,
        path: &amp;#39;/home&amp;#39;
    },
    {
        name: &amp;#39;users&amp;#39;,
        path: &amp;#39;/users&amp;#39;,
        onActivate: (params) =&amp;gt; fetch(&amp;#39;/users&amp;#39;).then(data =&amp;gt; ({ users: data.users }))
    },
    {
        name: &amp;#39;users.user&amp;#39;,
        path: &amp;#39;/:id&amp;#39;,
        onActivate: (params) =&amp;gt; fetch(`/users/${params.id}`).then(data =&amp;gt; ({ user: data.user }))
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we create a middleware function which will invoke data for the activated segments on a route change. In this example, data are loaded in parallel using &lt;code&gt;Promise.all&lt;/code&gt;. You can proceed differently by loading data in series, or by implementing dependencies between your &lt;code&gt;onActivate&lt;/code&gt; handlers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript javascript&quot;&gt;import transitionPath from &amp;#39;router5.transition-path&amp;#39;;

const dataMiddlewareFactory = (routes) =&amp;gt; (router) =&amp;gt; (toState, fromState) =&amp;gt; {
    const { toActivate } = transitionPath(toState, fromState);
    const onActivateHandlers =
        toActivate
            .map(segment =&amp;gt; routes.find(r =&amp;gt; r.name === segment).onActivate)
            .filter(Boolean)

    return Promise
        .all(onActivateHandlers)
        .then(data =&amp;gt; {
            const routeData = data.reduce((accData, rData) =&amp;gt; Object.assign(accData, rData), {});
            return { ...toState, data: routeData };
        });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And when configuring your router:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript javascript&quot;&gt;import { routes } from &amp;#39;./routes&amp;#39;;

const router = createRouter(routes);
/* ... configure your router */

/* data middleware */
router.useMiddleware(dataMiddlewareFactory(routes));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the case you don&amp;#39;t want a route transition to wait for data to be loaded, you cannot use the router state object as a data container. Instead, you should load data from your components or use a state container like &lt;a href=&quot;http://rackt.org/redux/index.html&quot;&gt;redux&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;using-a-state-container-redux-&quot;&gt;Using a state container (redux)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Using a state container like redux gives you a lot more flexibility with your routing strategy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Using a state container like redux gives you a lot more flexibility with your routing strategy. Because all data ends up in the same bucket that your components can listen to, data loading doesn&amp;#39;t need to block route transitions. The only thing it needs is a reference to your store so actions can be dispatched. As a result, your view can represent with greater details the state of your application: for example your UI can be a lot more explicit about displaying loading feedback. Not blocking route transitions also means immediate URL updates (history), making your app feel more responsive.&lt;/p&gt;
&lt;p&gt;The following example assumes the use a redux store configured with a &lt;code&gt;redux-thunk&lt;/code&gt; middleware.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript javascript&quot;&gt;import { loadUsers, loadUser } from &amp;#39;./actionCreators&amp;#39;;

const routes = [
    {
        name: &amp;#39;home&amp;#39;,
        path: &amp;#39;/home&amp;#39;
    },
    {
        name: &amp;#39;users&amp;#39;,
        path: &amp;#39;/users&amp;#39;,
        onActivate: (params) =&amp;gt; (dispatch) =&amp;gt;
            fetch(&amp;#39;/users&amp;#39;).then(data =&amp;gt; dispatch(loadUsers(data.users)))
    },
    {
        name: &amp;#39;users.user&amp;#39;,
        path: &amp;#39;/:id&amp;#39;,
        onActivate: (params) =&amp;gt; (dispatch) =&amp;gt;
            fetch(`/users/${params.id}`).then(data =&amp;gt; dispatch(loadUser(data.user)))
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You need to create your store and router, and pass your store to your router instance (with &lt;code&gt;.setDependency()&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript javascript&quot;&gt;router.setDependency(&amp;#39;store&amp;#39;, store);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we create a router5 middleware for data which will load data on a transition success.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript javascript&quot;&gt;import { actionTypes } from &amp;#39;redux-router5&amp;#39;;
import transitionPath from &amp;#39;router5.transition-path&amp;#39;;

const onRouteActivateMiddleware = (routes) =&amp;gt; (router, dependencies) =&amp;gt; (toState, fromState, done) =&amp;gt; {
    const { toActivate } = transitionPath(toState, fromState);

    toActivate.forEach(segment =&amp;gt; {
        const routeSegment = routes.find(r =&amp;gt; r.name === segment);

        if (routeSegment &amp;amp;&amp;amp; routeSegment.onActivate) {
            dependencies.store.dispatch(routeSegment.onActivate(toState.params));
        }
    });

    done();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, just create your store and include &lt;code&gt;onRouteActivateMiddleware(routes)&lt;/code&gt; middleware.&lt;/p&gt;
&lt;h2 id=&quot;async-data-loading-and-universal-applications&quot;&gt;Async data loading and universal applications&lt;/h2&gt;
&lt;p&gt;The two examples above show two different techniques of loading data with a router5 middleware. One is blocking, one is non-blocking. But what about universal applications?&lt;/p&gt;
&lt;p&gt;The answer is very simple: block on the server-side, and choose to block or not on the client-side! For the example with example, you would need dispatch to return promises (with redux-thunk, your thunks need to return promises for their async operations).&lt;/p&gt;
&lt;h2 id=&quot;chunk-loading&quot;&gt;Chunk loading&lt;/h2&gt;
&lt;p&gt;Chunk loading (loading code asynchronoulsy) is similar to data loading, since one can consider code is a form of data. With middlewares, you can call a done callback or return a promise, making them perfectly usable with &lt;code&gt;require.ensure&lt;/code&gt; or &lt;code&gt;System.import&lt;/code&gt;. Like examples above, you can implement similar techniques with, let&amp;#39;s say, a &lt;code&gt;loadComponent&lt;/code&gt; route property.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;const routes = {
        name: &amp;#39;users&amp;#39;,
        path: &amp;#39;/users&amp;#39;,
        onActivate: (params) =&amp;gt; (dispatch) =&amp;gt;
            fetch(&amp;#39;/users&amp;#39;).then(data =&amp;gt; dispatch(loadUsers(data.users))),
        loadComponent: () =&amp;gt; System.import(&amp;#39;./views/UsersList&amp;#39;)
    },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then what you need is a middleware triggering &lt;code&gt;loadComponent&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are also emerging techniques of anticipated loading rather than lazy loading (i.e. from a specific view / component, chunks are loaded in anticipation of where a user is likely to go next). We could implement a &lt;code&gt;relatedComponents&lt;/code&gt; property.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-js&quot;&gt;const routes = [
    {
        name: &amp;#39;home&amp;#39;,
        path: &amp;#39;/home&amp;#39;,
        loadComponent: () =&amp;gt; System.import(&amp;#39;./views/Home&amp;#39;),
        relatedComponents: [ &amp;#39;users&amp;#39; ]
    },
    {
        name: &amp;#39;users&amp;#39;,
        path: &amp;#39;/users&amp;#39;,
        onActivate: (params) =&amp;gt; (dispatch) =&amp;gt;
            fetch(&amp;#39;/users&amp;#39;).then(data =&amp;gt; dispatch(loadUsers(data.users))),
        loadComponent: () =&amp;gt; System.import(&amp;#39;./views/UsersList&amp;#39;),
        relatedComponents: [ &amp;#39;home&amp;#39; ]
    },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then on a transition, what you might want to consider this strategy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Load data and component (chunk)&lt;/li&gt;
&lt;li&gt;Once done, request idle callback to start loading sibling components&lt;/li&gt;
&lt;/ul&gt;

    </main>

    <footer class="">
    &copy; Thomas Roch

    |

    <a href="https://github.com/router5/router5/blob/master/LICENSE">Licence MIT</a>

    |

    <a href="https://github.com/router5/router5/graphs/contributors">Contributors</a>

    |

    <a href="https://github.com/router5/router5/issues">issues</a>
</footer>


    <!-- Scripts -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js" charset="utf-8"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    


    <!-- Script files -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-64765998-1', 'auto');
      ga('send', 'pageview');
    </script>

    <script>
        window.addEventListener('scroll', function () {
            if (window.document.body.scrollTop > 0) {
                window.document.body.classList.add('scrolled');
            } else {
                window.document.body.classList.remove('scrolled');
            }
        });
    </script>
</body>

</html>
